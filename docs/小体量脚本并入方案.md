# 小体量脚本并入分析（当前 Scripts 仓库）

## 1. 统计口径
- 统计对象：`*.cs`。
- “小体量”定义：
  - **超小**：`<= 20` 行（大多为接口、数据壳、单一工具函数）；
  - **较小**：`21~60` 行（通常为轻量行为组件或配置承载）。
- 统计命令：
  - `find . -name '*.cs' -print0 | xargs -0 wc -l | sort -n`

## 2. 小体量脚本清单（节选）

### 2.1 超小（<=20 行）
- `Combat/IHittable.cs`（4）
- `Player/PlayerHitBox.cs`（5）
- `Enemy/IEnemyCombat.cs`（9）
- `Combat/IHitBox.cs`（10）
- `Public/BillboardToCamera.cs`（13）
- `Public/SavePoint.cs`（13）
- `Combat/HitResult.cs`（15）
- `Enemy/EnemyExperienceValue.cs`（16）
- `Combat/HitBoxLimb.cs`（17）
- `Public/LockTargetPointUtility.cs`（20）

### 2.2 较小（21~60 行）
- `Combat/HitReactionFilter.cs`（27）
- `Enemy/EnemyHitBox.cs`（30）
- `Enemy/AssassinationTarget.cs`（33）
- `Public/CombatSignals.cs`（38）
- `Combat/AttackConfig.cs`（39）
- `Public/CombatSfxSignals.cs`（41）
- `Combat/SwordController.cs`（42）
- `Player/PlayerSavePointInteractor.cs`（42）
- `Combat/CombatEnums.cs`（44）
- `Combat/AttackData.cs`（55）
- `Enemy/BossCombatTag.cs`（55）
- `Public/NoiseEmitter.cs`（57）
- `Player/PlayerDroneSummoner.cs`（60）

---

## 3. 并入可行性分级

> 原则：**不是所有小文件都该并**。接口/枚举/信号中心类拆分后可读性和复用性更高，盲目并入会降低边界清晰度。

### A. 建议并入（优先）

1) `Enemy/EnemyExperienceValue.cs` 并入 `Enemy/EnemyExperienceGiver.cs`
- 原因：`EnemyExperienceValue`仅承载一个 `int` 并做 `OnValidate` 下限保护，且当前由 `EnemyExperienceGiver`直接消费。
- 方案：
  - 在 `EnemyExperienceGiver`内新增序列化字段 `experienceValue`；
  - 保留对旧 `EnemyExperienceValue` 的兼容读取（迁移期）；
  - 完成预制体回填后删除 `EnemyExperienceValue`。
- 收益：减少“单字段壳组件”。

2) `Public/SavePoint.cs` 并入 `Public/SavePointManager.cs`（以“数据结构+编辑器引用”方式）
- 原因：`SavePoint`目前仅承载锚点数据，不含行为。
- 方案（稳妥）：
  - 先引入 `SavePointData`（可序列化结构）到 `SavePointManager`，支持集中管理；
  - `SavePoint`变为迁移层（deprecated），仅转发数据；
  - 场景稳定后再删除 `SavePoint`。
- 风险：`PlayerSavePointInteractor` 通过碰撞体 `GetComponentInParent<SavePoint>()` 寻址，若直接删类会影响触发逻辑，需先替换触发识别机制。

3) `Enemy/AssassinationTarget.cs` 并入 `Enemy/EnemyController.cs`（或 `CombatStats`）
- 原因：该类是“可暗杀/可处决 + 锚点 + 距离”的纯配置容器，语义贴近敌人主控。
- 方案：
  - 在 `EnemyController`中内聚这些字段并提供 `GetAnchorOrSelf`；
  - `AssassinationSystem`改为直接读 `EnemyController`（保留对旧组件兜底一段时间）。
- 风险：改动关联 `AssassinationSystem` 的目标筛选，需做回归测试。

### B. 视团队偏好可并入（中优先）

4) `Public/BillboardToCamera.cs` 并入通用视觉工具组件（如 UI/标记跟随类）
- 原因：单职责极小。
- 不建议直接并入大型控制器；建议并入一个“公共视觉行为集合”文件，避免零散。

5) `Public/LockTargetPointUtility.cs` 并入锁定系统相关类（如 `Player/LockOnSystem.cs`）
- 原因：目前是单函数静态工具，被多处调用。
- 约束：被 `Player/Enemy/Drone`多端依赖（调用点很多），若并入具体类会增加跨模块耦合。
- 更佳做法：保留独立工具类，不并入业务类；如确要并，至少并入 `Public` 下公共 `TargetingUtility` 聚合文件，而不是某个 Player 类。

### C. 不建议并入（保持独立）

6) 接口类：`IHittable`、`IHitBox`、`IEnemyCombat`
- 原因：是模块边界契约；并到实现类会破坏抽象层次，影响查找与复用。

7) 枚举/数据定义：`HitBoxLimb`、`HitResult`、`CombatEnums`、`AttackData`
- 原因：这些类型被跨模块高频引用，独立文件可降低循环依赖与冲突。

8) 事件总线：`CombatSignals`、`CombatSfxSignals`
- 原因：被多系统订阅/发布，独立能维持“单一通信入口”；并入任一业务类都会造成方向反转和耦合上升。

9) `Enemy/EnemyHitBox.cs`、`Combat/HitReactionFilter.cs`
- 原因：虽小，但属于“可挂载、可替换”的行为策略点，单独组件利于按敌人配置差异化。

---

## 4. 推荐执行顺序（低风险到高风险）

1. **第一批（低风险）**：`EnemyExperienceValue -> EnemyExperienceGiver`
2. **第二批（中风险）**：`AssassinationTarget -> EnemyController`（保留兼容）
3. **第三批（高风险）**：`SavePoint -> SavePointManager`（涉及碰撞触发寻址与场景对象组织）

每一批均建议采用：
- 先“并存 + 兼容读取”；
- 完成场景/预制体自动修复；
- 再删旧类。

## 5. 迁移落地建议（工程化）
- 增加一次性“场景/预制体扫描脚本”：输出仍依赖旧组件的对象列表。
- 对被弃用组件加 `[Obsolete]` 和 `HelpURL` 提示。
- 每批迁移后至少回归：
  - 近战命中与受击流程；
  - 存档点交互/复活点；
  - 暗杀与处决判定；
  - 音效与战斗信号事件监听。

## 6. 结论
- 当前仓库确实存在若干“体量很小且可并入”的组件，但**只建议并入配置壳类**，不要并入接口、枚举和信号中心。
- 若目标是“减少文件数”，优先做 `EnemyExperienceValue`、`AssassinationTarget`，`SavePoint`需要更谨慎的迁移分层。
